¦type¦qualified name¦signature¦description
¦procedure¦n10s.add.node¦n10s.add.node(uri :: STRING?, types :: LIST? OF STRING?, properties :: LIST? OF MAP?) :: (node :: NODE?)¦creates a node in the graph following the existing GraphConfig.
¦procedure¦n10s.add.relationship.nodes¦n10s.add.relationship.nodes(from :: NODE?, type :: STRING?, properties :: LIST? OF MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)¦creates a relationship in the graph following the existing GraphConfig.
¦procedure¦n10s.add.relationship.uris¦n10s.add.relationship.uris(from :: STRING?, type :: STRING?, properties :: LIST? OF MAP?, to :: STRING?) :: (rel :: RELATIONSHIP?)¦creates a relationship in the graph following the existing GraphConfig.
¦procedure¦n10s.experimental.export.dimodel.fetch¦n10s.experimental.export.dimodel.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (modelFile :: STRING?, mappingsScript :: STRING?, summary :: STRING?)¦Generates a data importer tool model aligned with the selected ontology
¦procedure¦n10s.experimental.export.dimodel.inline¦n10s.experimental.export.dimodel.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (modelFile :: STRING?, mappingsScript :: STRING?, summary :: STRING?)¦Generates a data importer tool model aligned with the selected ontology
¦procedure¦n10s.experimental.importJSONAsTree¦n10s.experimental.importJSONAsTree(containerNode :: NODE?, jsonpayload :: STRING?, connectingRel = _jsonTree :: STRING?) :: (node :: NODE?)¦Imports a json payload and maps it to nodes and relationships (JSON-LD style). Requires a uniqueness constraint on :Resource(uri)
¦procedure¦n10s.experimental.quadrdf.delete.fetch¦n10s.experimental.quadrdf.delete.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesDeleted :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?)¦
¦procedure¦n10s.experimental.quadrdf.delete.inline¦n10s.experimental.quadrdf.delete.inline(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesDeleted :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?)¦
¦procedure¦n10s.experimental.quadrdf.import.fetch¦n10s.experimental.quadrdf.import.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesLoaded :: INTEGER?, triplesParsed :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?, callParams :: MAP?)¦
¦procedure¦n10s.experimental.quadrdf.import.inline¦n10s.experimental.quadrdf.import.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesLoaded :: INTEGER?, triplesParsed :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?, callParams :: MAP?)¦Imports an RDF snippet passed as parameter and stores it in Neo4j as a property graph. Requires a unique constraint on :Resource(uri)
¦procedure¦n10s.experimental.stream.dimodel.fetch¦n10s.experimental.stream.dimodel.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (modelFile :: STRING?, mappingsScript :: STRING?, summary :: STRING?)¦Generates a data importer tool model aligned with the selected ontology
¦procedure¦n10s.experimental.stream.dimodel.inline¦n10s.experimental.stream.dimodel.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (modelFile :: STRING?, mappingsScript :: STRING?, summary :: STRING?)¦Generates a data importer tool model aligned with the selected ontology
¦procedure¦n10s.graphconfig.drop¦n10s.graphconfig.drop() :: (param :: STRING?, value :: ANY?)¦removes the current graph config
¦procedure¦n10s.graphconfig.init¦n10s.graphconfig.init(params = {} :: MAP?) :: (param :: STRING?, value :: ANY?)¦Initialises the config that drives the behavior of the graph
¦procedure¦n10s.graphconfig.set¦n10s.graphconfig.set(params = {} :: MAP?) :: (param :: STRING?, value :: ANY?)¦sets specific params to the config that drives the behavior of the graph
¦procedure¦n10s.graphconfig.show¦n10s.graphconfig.show() :: (param :: STRING?, value :: ANY?)¦Shows the current graph config
¦procedure¦n10s.inference.getRels¦n10s.inference.getRels(node :: NODE?, rel :: STRING?, params = {} :: MAP?) :: (rel :: RELATIONSHIP?, node :: NODE?)¦n10s.inference.getRels(node,'rel', { relDir: '>'} ) - returns all relationships of type 'rel' or its subtypes along with the target nodes.
¦procedure¦n10s.inference.nodesInCategory¦n10s.inference.nodesInCategory(category :: NODE?, params = {} :: MAP?) :: (node :: NODE?)¦n10s.inference.nodesInCategory('category') - returns all nodes connected to Node 'catNode' or its subcategories.
¦procedure¦n10s.inference.nodesLabelled¦n10s.inference.nodesLabelled(label :: STRING?, params = {} :: MAP?) :: (node :: NODE?)¦n10s.inference.nodesLabelled('label') - returns all nodes with label 'label' or its sublabels.
¦procedure¦n10s.mapping.add¦n10s.mapping.add(elementUri :: STRING?, graphElementName :: STRING?) :: (schemaNs :: STRING?, schemaPrefix :: STRING?, schemaElement :: STRING?, elemName :: STRING?)¦
¦procedure¦n10s.mapping.drop¦n10s.mapping.drop(graphElementName :: STRING?) :: (output :: STRING?)¦
¦procedure¦n10s.mapping.dropAll¦n10s.mapping.dropAll(namespace :: STRING?) :: (output :: STRING?)¦
¦procedure¦n10s.mapping.list¦n10s.mapping.list(schemaElem =  :: STRING?) :: (schemaNs :: STRING?, schemaPrefix :: STRING?, schemaElement :: STRING?, elemName :: STRING?)¦
¦procedure¦n10s.nsprefixes.add¦n10s.nsprefixes.add(prefix :: STRING?, ns :: STRING?) :: (prefix :: STRING?, namespace :: STRING?)¦Adds namespace - prefix pair definition
¦procedure¦n10s.nsprefixes.addFromText¦n10s.nsprefixes.addFromText(prefix :: STRING?) :: (prefix :: STRING?, namespace :: STRING?)¦Adds namespaces from a prefix declaration header fragment
¦procedure¦n10s.nsprefixes.list¦n10s.nsprefixes.list() :: (prefix :: STRING?, namespace :: STRING?)¦Lists all existing namespace prefix definitions
¦procedure¦n10s.nsprefixes.remove¦n10s.nsprefixes.remove(prefix :: STRING?) :: (prefix :: STRING?, namespace :: STRING?)¦removes namespace prefix (by prefix)
¦procedure¦n10s.nsprefixes.removeAll¦n10s.nsprefixes.removeAll() :: (prefix :: STRING?, namespace :: STRING?)¦removes all namespace prefixes
¦procedure¦n10s.onto.import.fetch¦n10s.onto.import.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesLoaded :: INTEGER?, triplesParsed :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?, callParams :: MAP?)¦Imports classes, properties (dataType and Object), hierarchies thereof, and domain and range info.
¦procedure¦n10s.onto.import.inline¦n10s.onto.import.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesLoaded :: INTEGER?, triplesParsed :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?, callParams :: MAP?)¦Imports classes, properties (dataType and Object), hierarchies thereof, and domain and range info.
¦procedure¦n10s.onto.preview.fetch¦n10s.onto.preview.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦Parses an ontology and produces virtual Nodes and relationships for preview in the Neo4j browser. No writing to the DB.
¦procedure¦n10s.onto.preview.inline¦n10s.onto.preview.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦Parses an ontology passed as parameter (no retrieval from url) and produces virtual Nodes and relationships for preview in the Neo4j browser. No writing to the DB.
¦procedure¦n10s.rdf.delete.fetch¦n10s.rdf.delete.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesDeleted :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?)¦Deletes triples (parsed from url) from Neo4j. Works on a graph resulted of importing RDF via n10s.rdf.import 
¦procedure¦n10s.rdf.delete.inline¦n10s.rdf.delete.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesDeleted :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?)¦Deletes triples (passed as string) from Neo4j. Works on a graph resulted of importing RDF via n10s.rdf.import 
¦procedure¦n10s.rdf.export.cypher¦n10s.rdf.export.cypher(cypher :: STRING?, params = {} :: MAP?) :: (subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, subjectSPO :: LIST? OF STRING?)¦Executes a cypher query returning graph elements (nodes,rels) and serialises the output as triples.
¦procedure¦n10s.rdf.export.spo¦n10s.rdf.export.spo(subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral = false :: BOOLEAN?, literalType = http://www.w3.org/2001/XMLSchema#string :: STRING?, literalLang = null :: STRING?, params = {} :: MAP?) :: (subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, subjectSPO :: LIST? OF STRING?)¦Returns the triples matching the spo pattern passed as parameter.
¦procedure¦n10s.rdf.import.fetch¦n10s.rdf.import.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesLoaded :: INTEGER?, triplesParsed :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?, callParams :: MAP?)¦Imports RDF from an url (file or http) and stores it in Neo4j as a property graph. Requires a unique constraint on :Resource(uri)
¦procedure¦n10s.rdf.import.inline¦n10s.rdf.import.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesLoaded :: INTEGER?, triplesParsed :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?, callParams :: MAP?)¦Imports an RDF snippet passed as parameter and stores it in Neo4j as a property graph. Requires a unique constraint on :Resource(uri)
¦procedure¦n10s.rdf.preview.fetch¦n10s.rdf.preview.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦Parses RDF and produces virtual Nodes and relationships for preview in the Neo4j browser. No writing to the DB.
¦procedure¦n10s.rdf.preview.inline¦n10s.rdf.preview.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦Parses an RDF fragment passed as parameter (no retrieval from url) and produces virtual Nodes and relationships for preview in the Neo4j browser. No writing to the DB.
¦procedure¦n10s.rdf.stream.fetch¦n10s.rdf.stream.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, subjectSPO :: LIST? OF STRING?)¦Parses RDF and streams each triple as a record with <S,P,O> along with datatype and language tag for Literal values. No writing to the DB.
¦procedure¦n10s.rdf.stream.inline¦n10s.rdf.stream.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, subjectSPO :: LIST? OF STRING?)¦Parses RDF passed as a string and streams each triple as a record with <S,P,O> along with datatype and language tag for Literal values. No writing to the DB.
¦procedure¦n10s.skos.import.fetch¦n10s.skos.import.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesLoaded :: INTEGER?, triplesParsed :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?, callParams :: MAP?)¦Imports classes, properties (dataType and Object), hierarchies thereof and domain and range info.
¦procedure¦n10s.skos.import.inline¦n10s.skos.import.inline(skosFragment :: STRING?, format :: STRING?, params = {} :: MAP?) :: (terminationStatus :: STRING?, triplesLoaded :: INTEGER?, triplesParsed :: INTEGER?, namespaces :: MAP?, extraInfo :: STRING?, callParams :: MAP?)¦Imports classes, properties (dataType and Object), hierarchies thereof and domain and range info.
¦procedure¦n10s.validation.shacl.dropShapes¦n10s.validation.shacl.dropShapes() :: (target :: STRING?, propertyOrRelationshipPath :: STRING?, param :: STRING?, value :: ANY?)¦n10s.validation.dropShapes() - list SHACL shapes loaded in the Graph
¦procedure¦n10s.validation.shacl.import.fetch¦n10s.validation.shacl.import.fetch(url :: STRING?, format :: STRING?, params = {} :: MAP?) :: (target :: STRING?, propertyOrRelationshipPath :: STRING?, param :: STRING?, value :: ANY?)¦Imports SHACL shapes from a URL and compiles a validator into neo4j
¦procedure¦n10s.validation.shacl.import.inline¦n10s.validation.shacl.import.inline(rdf :: STRING?, format :: STRING?, params = {} :: MAP?) :: (target :: STRING?, propertyOrRelationshipPath :: STRING?, param :: STRING?, value :: ANY?)¦Imports a SHACL shapes snippet passed as parameter and compiles a validator into neo4j
¦procedure¦n10s.validation.shacl.listShapes¦n10s.validation.shacl.listShapes() :: (target :: STRING?, propertyOrRelationshipPath :: STRING?, param :: STRING?, value :: ANY?)¦n10s.validation.listShapes() - list SHACL shapes loaded in the Graph
¦procedure¦n10s.validation.shacl.validate¦n10s.validation.shacl.validate() :: (focusNode :: ANY?, nodeType :: STRING?, shapeId :: STRING?, propertyShape :: STRING?, offendingValue :: ANY?, resultPath :: STRING?, severity :: STRING?, resultMessage :: STRING?)¦n10s.validation.shacl.validate() - runs SHACL validation on the whole graph.
¦procedure¦n10s.validation.shacl.validateSet¦n10s.validation.shacl.validateSet(nodeList = [] :: LIST? OF NODE?) :: (focusNode :: ANY?, nodeType :: STRING?, shapeId :: STRING?, propertyShape :: STRING?, offendingValue :: ANY?, resultPath :: STRING?, severity :: STRING?, resultMessage :: STRING?)¦n10s.validation.shacl.validateSet([nodeList]) - runs SHACL validation on selected nodes
¦procedure¦n10s.validation.shacl.validateTransaction¦n10s.validation.shacl.validateTransaction(createdNodes :: ANY?, createdRelationships :: ANY?, assignedLabels :: ANY?, removedLabels :: ANY?, assignedNodeProperties :: ANY?, removedNodeProperties :: ANY?, deletedRelationships :: ANY?, deletedNodes :: ANY?) :: (focusNode :: ANY?, nodeType :: STRING?, shapeId :: STRING?, propertyShape :: STRING?, offendingValue :: ANY?, resultPath :: STRING?, severity :: STRING?, resultMessage :: STRING?)¦n10s.validation.shacl.validateTransaction(createdNodes,createdRelationships,...) - runs SHACL validation in trigger context.
¦function¦n10s.aux.dt.check¦n10s.aux.dt.check(expectedType :: STRING?, actual :: ANY?) :: (BOOLEAN?)¦Checks if a value has a given datatype (XSD)
¦function¦n10s.inference.hasLabel¦n10s.inference.hasLabel(node :: NODE?, label :: STRING?, params = {} :: MAP?) :: (BOOLEAN?)¦n10s.inference.hasLabel(node,'label',{}) - checks whether node is explicitly or implicitly labeled as 'label'.
¦function¦n10s.inference.inCategory¦n10s.inference.inCategory(node :: NODE?, category :: NODE?, params = {} :: MAP?) :: (BOOLEAN?)¦n10s.inference.inCategory(node, category, {}) - checks whether node is explicitly or implicitly in a category.
¦function¦n10s.rdf.collect¦n10s.rdf.collect(subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, sspo = null :: LIST? OF STRING?) :: (STRING?)¦n10s.rdf.collect(subject,predicate,object,isLiteral,literalType,literalLang) - collects a set of triples as returned by n10s.rdf.export.* or n10s.rdf.stream.* and returns them serialised as N-triples
¦function¦n10s.rdf.collect.json¦n10s.rdf.collect.json(subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, sspo = null :: LIST? OF STRING?) :: (STRING?)¦n10s.rdf.collect(subject,predicate,object,isLiteral,literalType,literalLang) - collects a set of triples as returned by n10s.rdf.export.* or n10s.rdf.stream.* and returns them serialised as JSON-LD
¦function¦n10s.rdf.collect.nt¦n10s.rdf.collect.nt(subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, sspo = null :: LIST? OF STRING?) :: (STRING?)¦n10s.rdf.collect(subject,predicate,object,isLiteral,literalType,literalLang) - collects a set of triples as returned by n10s.rdf.export.* or n10s.rdf.stream.* and returns them serialised as Turtle
¦function¦n10s.rdf.collect.ttl¦n10s.rdf.collect.ttl(subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, sspo = null :: LIST? OF STRING?) :: (STRING?)¦n10s.rdf.collect(subject,predicate,object,isLiteral,literalType,literalLang) - collects a set of triples as returned by n10s.rdf.export.* or n10s.rdf.stream.* and returns them serialised as Turtle
¦function¦n10s.rdf.collect.ttlstar¦n10s.rdf.collect.ttlstar(subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, sspo = null :: LIST? OF STRING?) :: (STRING?)¦n10s.rdf.collect(subject,predicate,object,isLiteral,literalType,literalLang) - collects a set of triples as returned by n10s.rdf.export.* or n10s.rdf.stream.* and returns them serialised as JSON-LD
¦function¦n10s.rdf.collect.xml¦n10s.rdf.collect.xml(subject :: STRING?, predicate :: STRING?, object :: STRING?, isLiteral :: BOOLEAN?, literalType :: STRING?, literalLang :: STRING?, sspo = null :: LIST? OF STRING?) :: (STRING?)¦n10s.rdf.collect(subject,predicate,object,isLiteral,literalType,literalLang) - collects a set of triples as returned by n10s.rdf.export.* or n10s.rdf.stream.* and returns them serialised as RDF/XML
¦function¦n10s.rdf.fullUriFromShortForm¦n10s.rdf.fullUriFromShortForm(short :: STRING?) :: (STRING?)¦Returns the expanded (full) IRI given a shortened one created in the load process with semantics.importRDF
¦function¦n10s.rdf.getDataType¦n10s.rdf.getDataType(literal :: ANY?) :: (STRING?)¦Returns the XMLSchema or custom datatype of a property when present
¦function¦n10s.rdf.getIRILocalName¦n10s.rdf.getIRILocalName(url :: STRING?) :: (STRING?)¦Returns the local part of an IRI
¦function¦n10s.rdf.getIRINamespace¦n10s.rdf.getIRINamespace(url :: STRING?) :: (STRING?)¦Returns the namespace part of an IRI
¦function¦n10s.rdf.getLangTag¦n10s.rdf.getLangTag(value :: ANY?) :: (STRING?)¦Returns the language tag of a value. Returns null if the value is not a string orif the string has no language tag
¦function¦n10s.rdf.getLangValue¦n10s.rdf.getLangValue(lang :: STRING?, values :: ANY?) :: (STRING?)¦Returns the first value with the language tag passed as first argument or null if there's not a value for the provided tag
¦function¦n10s.rdf.getValue¦n10s.rdf.getValue(literal :: STRING?) :: (STRING?)¦Returns the value of a datatype of a property after stripping out the datatype information when present
¦function¦n10s.rdf.hasLangTag¦n10s.rdf.hasLangTag(lang :: STRING?, value :: ANY?) :: (BOOLEAN?)¦Returns false if the value is not a string or if the string is not tagged with the  given language tag
¦function¦n10s.rdf.isIRI¦n10s.rdf.isIRI(str :: STRING?) :: (BOOLEAN?)¦Returns the true if string is a valid IRI
¦function¦n10s.rdf.shortFormFromFullUri¦n10s.rdf.shortFormFromFullUri(uri :: STRING?) :: (STRING?)¦Returns the shortened version of an IRI using the existing namespace definitions
¦function¦n10s.version¦n10s.version() :: (STRING?)¦RETURN n10s.version() | return the version of n10s currently installed
